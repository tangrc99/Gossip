<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gossip: gossip::server::GossipNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="gossip.jpeg"/></td>
  <td id="projectalign">
   <div id="projectname">Gossip<span id="projectnumber">&#160;1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>gossip</b></li><li class="navelem"><b>server</b></li><li class="navelem"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html">GossipNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgossip_1_1server_1_1_gossip_node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">gossip::server::GossipNode Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Gossip node server, handles client's and other node's request.  
 <a href="classgossip_1_1server_1_1_gossip_node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_gossip_node_8h_source.html">GossipNode.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a51de4ba94b1d60fea91364023ce2558e"><td class="memItemLeft" align="right" valign="top"><a id="a51de4ba94b1d60fea91364023ce2558e" name="a51de4ba94b1d60fea91364023ce2558e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RetryCall</b> = <a class="el" href="structgossip_1_1server_1_1_gossip_peer_node_1_1_async_client_call.html">GossipPeerNode::AsyncClientCall</a>&lt; google::protobuf::Any, google::protobuf::Any &gt;</td></tr>
<tr class="separator:a51de4ba94b1d60fea91364023ce2558e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab8374e6d4f73f621d8c91d8022c9c29b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#ab8374e6d4f73f621d8c91d8022c9c29b">GossipNode</a> (std::string name, std::string ex_addr, std::string in_addr, std::string token=&quot;&quot;)</td></tr>
<tr class="separator:ab8374e6d4f73f621d8c91d8022c9c29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97385ac4f6c0e17c6d4850c34b6210fa"><td class="memItemLeft" align="right" valign="top"><a id="a97385ac4f6c0e17c6d4850c34b6210fa" name="a97385ac4f6c0e17c6d4850c34b6210fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~GossipNode</b> ()</td></tr>
<tr class="memdesc:a97385ac4f6c0e17c6d4850c34b6210fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of <a class="el" href="classgossip_1_1server_1_1_gossip_node.html" title="Gossip node server, handles client&#39;s and other node&#39;s request.">GossipNode</a>. Recycle the sources claimed. <br /></td></tr>
<tr class="separator:a97385ac4f6c0e17c6d4850c34b6210fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c75353a9b3c309aa3141d19f582c74"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#aa5c75353a9b3c309aa3141d19f582c74">internalAddress</a> () const</td></tr>
<tr class="separator:aa5c75353a9b3c309aa3141d19f582c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810bd3e4b54c7fc9d9f96a24ec4ad1a6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#a810bd3e4b54c7fc9d9f96a24ec4ad1a6">externalAddress</a> () const</td></tr>
<tr class="separator:a810bd3e4b54c7fc9d9f96a24ec4ad1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a87a2e40225bce9d03508b21d89fd8"><td class="memItemLeft" align="right" valign="top"><a id="a85a87a2e40225bce9d03508b21d89fd8" name="a85a87a2e40225bce9d03508b21d89fd8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>run</b> ()</td></tr>
<tr class="memdesc:a85a87a2e40225bce9d03508b21d89fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run this gossip node. <br /></td></tr>
<tr class="separator:a85a87a2e40225bce9d03508b21d89fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aec9f94cf810b122cbfcc184f14cbbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#a5aec9f94cf810b122cbfcc184f14cbbe">stop</a> ()</td></tr>
<tr class="separator:a5aec9f94cf810b122cbfcc184f14cbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae026ebe0965f29e3e32d759c8cc97f05"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgossip_1_1server_1_1_gossip_slot.html">GossipSlot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#ae026ebe0965f29e3e32d759c8cc97f05">localSlot</a> () const</td></tr>
<tr class="separator:ae026ebe0965f29e3e32d759c8cc97f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a9a17d8e3fb5105d46eefe0c7ede6b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#aa0a9a17d8e3fb5105d46eefe0c7ede6b">NodeName</a> () const</td></tr>
<tr class="separator:aa0a9a17d8e3fb5105d46eefe0c7ede6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac505abf639dee73e8e05cc4997b57355"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#ac505abf639dee73e8e05cc4997b57355">Token</a> () const</td></tr>
<tr class="separator:ac505abf639dee73e8e05cc4997b57355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1cd82643feb3de6e90d7438c843f2b"><td class="memItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#a9a1cd82643feb3de6e90d7438c843f2b">getNodeStatus</a> ()</td></tr>
<tr class="separator:a9a1cd82643feb3de6e90d7438c843f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcb2218e9c693e5873a591c0c918b61"><td class="memItemLeft" align="right" valign="top">SlotVersion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#a1dcb2218e9c693e5873a591c0c918b61">insertOrUpdateMessage</a> (const std::string &amp;key, const std::string &amp;value)</td></tr>
<tr class="separator:a1dcb2218e9c693e5873a591c0c918b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b0b1233eefe0a2d3a46d693baf01cf"><td class="memItemLeft" align="right" valign="top">SlotVersion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#a21b0b1233eefe0a2d3a46d693baf01cf">deleteMessage</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a21b0b1233eefe0a2d3a46d693baf01cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09444859e47f7ad4db697b4af398d57c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#a09444859e47f7ad4db697b4af398d57c">getMessage</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a09444859e47f7ad4db697b4af398d57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1b1ec2bbc0e43ff65f1291ce228eac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpf__gossip_1_1_search_result.html">pf_gossip::SearchResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#a3b1b1ec2bbc0e43ff65f1291ce228eac">searchMessage</a> (const std::string &amp;key, bool latest)</td></tr>
<tr class="separator:a3b1b1ec2bbc0e43ff65f1291ce228eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26799377e60948944867f018baacab5"><td class="memItemLeft" align="right" valign="top">SlotVersion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#af26799377e60948944867f018baacab5">handlePullRequest</a> (const std::string &amp;slot, const SlotValues &amp;values, SlotVersion version, const <a class="el" href="classpf__gossip_1_1_slot_update.html">pf_gossip::SlotUpdate</a> *origin)</td></tr>
<tr class="separator:af26799377e60948944867f018baacab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504800635f79460ccd1e6d93de756286"><td class="memItemLeft" align="right" valign="top">SlotVersion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#a504800635f79460ccd1e6d93de756286">handleHeartbeatRequest</a> (const std::string &amp;node_name, const std::string &amp;slot_name, SlotVersion version)</td></tr>
<tr class="separator:a504800635f79460ccd1e6d93de756286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa72b107b652703360a499110d7f9627"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#aaa72b107b652703360a499110d7f9627">handleNewNodeNotify</a> (const std::string &amp;name, const std::string &amp;address, SlotVersion version, const <a class="el" href="classpf__gossip_1_1_gossip_node_info.html">::pf_gossip::GossipNodeInfo</a> *origin)</td></tr>
<tr class="separator:aaa72b107b652703360a499110d7f9627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d9d23fdf7158914722d54e09a09bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#aa6d9d23fdf7158914722d54e09a09bec">handleDeleteNodeNotify</a> (const std::string &amp;name, const std::string &amp;address, SlotVersion version, const <a class="el" href="classpf__gossip_1_1_gossip_node_info.html">::pf_gossip::GossipNodeInfo</a> *origin)</td></tr>
<tr class="separator:aa6d9d23fdf7158914722d54e09a09bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5223821d75361cf7938ae784732cb37"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#ac5223821d75361cf7938ae784732cb37">startConnection</a> (const std::string &amp;address)</td></tr>
<tr class="separator:ac5223821d75361cf7938ae784732cb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d3cd2536825085b0ebeaa19677735b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#ac8d3cd2536825085b0ebeaa19677735b">startHeartBeat</a> ()</td></tr>
<tr class="separator:ac8d3cd2536825085b0ebeaa19677735b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627d8c4314b027f691159245f94102a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#a627d8c4314b027f691159245f94102a3">startDeleteNodeNotify</a> ()</td></tr>
<tr class="separator:a627d8c4314b027f691159245f94102a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31205f0b03f0b036a0c0348b06e4f235"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#a31205f0b03f0b036a0c0348b06e4f235">startNewNodeNotify</a> (const std::string &amp;name, const std::string &amp;address, SlotVersion version)</td></tr>
<tr class="separator:a31205f0b03f0b036a0c0348b06e4f235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3672d5d0a3445483645b7f1bd163bdf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgossip_1_1server_1_1_gossip_node.html#a3672d5d0a3445483645b7f1bd163bdf5">addRetryTask</a> (<a class="el" href="structgossip_1_1server_1_1_gossip_peer_node_1_1_async_client_call.html">GossipPeerNode::AsyncClientCall</a>&lt; google::protobuf::Any, google::protobuf::Any &gt; *call)</td></tr>
<tr class="separator:a3672d5d0a3445483645b7f1bd163bdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Gossip node server, handles client's and other node's request. </p>
<p >Class <a class="el" href="classgossip_1_1server_1_1_gossip_node.html" title="Gossip node server, handles client&#39;s and other node&#39;s request.">GossipNode</a> handles gossip client's and gossip peer node's rpc request, and maintains a K-V map in memory. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab8374e6d4f73f621d8c91d8022c9c29b" name="ab8374e6d4f73f621d8c91d8022c9c29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8374e6d4f73f621d8c91d8022c9c29b">&#9670;&nbsp;</a></span>GossipNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gossip::server::GossipNode::GossipNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ex_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>in_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>token</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor of <a class="el" href="classgossip_1_1server_1_1_gossip_node.html" title="Gossip node server, handles client&#39;s and other node&#39;s request.">GossipNode</a>. Create gossip peer node listen port and gossip client listen port. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of gossip node. Used to identify different gossip slot. </td></tr>
    <tr><td class="paramname">ex_addr</td><td>Gossip client listen address. If is set "", means don't open client port. </td></tr>
    <tr><td class="paramname">in_addr</td><td>Gossip peer node listen address. If is set "", means don't open peer node port. </td></tr>
    <tr><td class="paramname">token</td><td>Gossip Client Entry token. If not set, this node will acquire no token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3672d5d0a3445483645b7f1bd163bdf5" name="a3672d5d0a3445483645b7f1bd163bdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3672d5d0a3445483645b7f1bd163bdf5">&#9670;&nbsp;</a></span>addRetryTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gossip::server::GossipNode::addRetryTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgossip_1_1server_1_1_gossip_peer_node_1_1_async_client_call.html">GossipPeerNode::AsyncClientCall</a>&lt; google::protobuf::Any, google::protobuf::Any &gt; *&#160;</td>
          <td class="paramname"><em>call</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add a retry task in gossip retry tasks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call</td><td>A rpc async object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21b0b1233eefe0a2d3a46d693baf01cf" name="a21b0b1233eefe0a2d3a46d693baf01cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b0b1233eefe0a2d3a46d693baf01cf">&#9670;&nbsp;</a></span>deleteMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SlotVersion gossip::server::GossipNode::deleteMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle gossip client's delete request by key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated slot version </dd></dl>

</div>
</div>
<a id="a810bd3e4b54c7fc9d9f96a24ec4ad1a6" name="a810bd3e4b54c7fc9d9f96a24ec4ad1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810bd3e4b54c7fc9d9f96a24ec4ad1a6">&#9670;&nbsp;</a></span>externalAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gossip::server::GossipNode::externalAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the gossip client address of this gossip node. </p><dl class="section return"><dt>Returns</dt><dd>Gossip client address </dd></dl>

</div>
</div>
<a id="a09444859e47f7ad4db697b4af398d57c" name="a09444859e47f7ad4db697b4af398d57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09444859e47f7ad4db697b4af398d57c">&#9670;&nbsp;</a></span>getMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string gossip::server::GossipNode::getMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle gossip client's read request by key. This function only finds value in local slot. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Latest value </dd></dl>

</div>
</div>
<a id="a9a1cd82643feb3de6e90d7438c843f2b" name="a9a1cd82643feb3de6e90d7438c843f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1cd82643feb3de6e90d7438c843f2b">&#9670;&nbsp;</a></span>getNodeStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nlohmann::json gossip::server::GossipNode::getNodeStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the status of this gossip node. </p><dl class="section return"><dt>Returns</dt><dd>The status of gossip node </dd></dl>

</div>
</div>
<a id="aa6d9d23fdf7158914722d54e09a09bec" name="aa6d9d23fdf7158914722d54e09a09bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d9d23fdf7158914722d54e09a09bec">&#9670;&nbsp;</a></span>handleDeleteNodeNotify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gossip::server::GossipNode::handleDeleteNodeNotify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlotVersion&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpf__gossip_1_1_gossip_node_info.html">::pf_gossip::GossipNodeInfo</a> *&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle gossip peer node's node delete notify. This node will set that node unhealthy and then check its real status. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of deleted node </td></tr>
    <tr><td class="paramname">address</td><td>The address of deleted node </td></tr>
    <tr><td class="paramname">version</td><td>The version of deleted node </td></tr>
    <tr><td class="paramname">origin</td><td>Received message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a504800635f79460ccd1e6d93de756286" name="a504800635f79460ccd1e6d93de756286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504800635f79460ccd1e6d93de756286">&#9670;&nbsp;</a></span>handleHeartbeatRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SlotVersion gossip::server::GossipNode::handleHeartbeatRequest </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>node_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>slot_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlotVersion&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle gossip peer node's heartbeat request. If peer node's version is higher than this or the same as this, function will do nothing. If peer node's version is less than this, function will put peer node to lower_slots and delayed pull this node's slot to that peer node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_name</td><td>Node name of peer node </td></tr>
    <tr><td class="paramname">slot_name</td><td>Slot name to compare </td></tr>
    <tr><td class="paramname">version</td><td>Version of peer node's slot </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This node's slot version </dd></dl>

</div>
</div>
<a id="aaa72b107b652703360a499110d7f9627" name="aaa72b107b652703360a499110d7f9627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa72b107b652703360a499110d7f9627">&#9670;&nbsp;</a></span>handleNewNodeNotify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gossip::server::GossipNode::handleNewNodeNotify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlotVersion&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpf__gossip_1_1_gossip_node_info.html">::pf_gossip::GossipNodeInfo</a> *&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle gossip peer node's new node notify. If the new node is not connected, this node will connect to it. Otherwise, this node will do nothing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of new node </td></tr>
    <tr><td class="paramname">address</td><td>The address of new node </td></tr>
    <tr><td class="paramname">version</td><td>The version of new node </td></tr>
    <tr><td class="paramname">origin</td><td>Received message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If connect to new node successfully </dd></dl>

</div>
</div>
<a id="af26799377e60948944867f018baacab5" name="af26799377e60948944867f018baacab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26799377e60948944867f018baacab5">&#9670;&nbsp;</a></span>handlePullRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SlotVersion gossip::server::GossipNode::handlePullRequest </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotValues &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlotVersion&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpf__gossip_1_1_slot_update.html">pf_gossip::SlotUpdate</a> *&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle gossip peer node's pull request. Node will first propagate message to another nodes and then compare and update this node's slot. If slot is updated, function returns new version; if not, function returns original version. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>Slot name </td></tr>
    <tr><td class="paramname">values</td><td>Slot values </td></tr>
    <tr><td class="paramname">version</td><td>Slot version </td></tr>
    <tr><td class="paramname">origin</td><td>Peer's request </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated slot version. If not updated, returns original version. </dd></dl>

</div>
</div>
<a id="a1dcb2218e9c693e5873a591c0c918b61" name="a1dcb2218e9c693e5873a591c0c918b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcb2218e9c693e5873a591c0c918b61">&#9670;&nbsp;</a></span>insertOrUpdateMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SlotVersion gossip::server::GossipNode::insertOrUpdateMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle gossip client's insert or update request. Using the request handled time as slot version. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of message </td></tr>
    <tr><td class="paramname">value</td><td>The value of message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated slot version </dd></dl>

</div>
</div>
<a id="aa5c75353a9b3c309aa3141d19f582c74" name="aa5c75353a9b3c309aa3141d19f582c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c75353a9b3c309aa3141d19f582c74">&#9670;&nbsp;</a></span>internalAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gossip::server::GossipNode::internalAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the gossip node address of this gossip node </p><dl class="section return"><dt>Returns</dt><dd>Gossip node address </dd></dl>

</div>
</div>
<a id="ae026ebe0965f29e3e32d759c8cc97f05" name="ae026ebe0965f29e3e32d759c8cc97f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae026ebe0965f29e3e32d759c8cc97f05">&#9670;&nbsp;</a></span>localSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgossip_1_1server_1_1_gossip_slot.html">GossipSlot</a> * gossip::server::GossipNode::localSlot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the copy of local slot. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classgossip_1_1server_1_1_gossip_slot.html" title="Memory map with different slots and versions.">GossipSlot</a> object </dd></dl>

</div>
</div>
<a id="aa0a9a17d8e3fb5105d46eefe0c7ede6b" name="aa0a9a17d8e3fb5105d46eefe0c7ede6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a9a17d8e3fb5105d46eefe0c7ede6b">&#9670;&nbsp;</a></span>NodeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gossip::server::GossipNode::NodeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the name of this gossip node. </p><dl class="section return"><dt>Returns</dt><dd>The name of this gossip node </dd></dl>

</div>
</div>
<a id="a3b1b1ec2bbc0e43ff65f1291ce228eac" name="a3b1b1ec2bbc0e43ff65f1291ce228eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1b1ec2bbc0e43ff65f1291ce228eac">&#9670;&nbsp;</a></span>searchMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpf__gossip_1_1_search_result.html">pf_gossip::SearchResult</a> gossip::server::GossipNode::searchMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>latest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle gossip client's read request by key. This function will finds version in all slot. If latest is set true, this node will ask the owner of message to get latest version. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of message </td></tr>
    <tr><td class="paramname">latest</td><td>Is latest version needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Find result </dd></dl>

</div>
</div>
<a id="ac5223821d75361cf7938ae784732cb37" name="ac5223821d75361cf7938ae784732cb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5223821d75361cf7938ae784732cb37">&#9670;&nbsp;</a></span>startConnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string gossip::server::GossipNode::startConnection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Send connect request to a gossip node, if succeed peer node will send notification to other gossip nodes that peer has connected to. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>ip address of peer node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether connection is established. If succeed, returns "". Otherwise, returns error information </dd></dl>

</div>
</div>
<a id="a627d8c4314b027f691159245f94102a3" name="a627d8c4314b027f691159245f94102a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627d8c4314b027f691159245f94102a3">&#9670;&nbsp;</a></span>startDeleteNodeNotify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gossip::server::GossipNode::startDeleteNodeNotify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Start a gossip transmit of node delete. This only happens when this node is down. Function randomly select some nodes to send notification rpc. </p>

</div>
</div>
<a id="ac8d3cd2536825085b0ebeaa19677735b" name="ac8d3cd2536825085b0ebeaa19677735b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d3cd2536825085b0ebeaa19677735b">&#9670;&nbsp;</a></span>startHeartBeat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gossip::server::GossipNode::startHeartBeat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Start a gossip transmit of heartbeat swap. This function randomly select a peer node to swap this node's local slot version. </p>

</div>
</div>
<a id="a31205f0b03f0b036a0c0348b06e4f235" name="a31205f0b03f0b036a0c0348b06e4f235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31205f0b03f0b036a0c0348b06e4f235">&#9670;&nbsp;</a></span>startNewNodeNotify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gossip::server::GossipNode::startNewNodeNotify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlotVersion&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Start a gossip transmit of new node. This will happen only when this node received a new node's connection request. Function randomly select some nodes to send notification rpc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>New gossip node's name </td></tr>
    <tr><td class="paramname">address</td><td>New gossip node's ip address </td></tr>
    <tr><td class="paramname">version</td><td>New gossip node's version </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5aec9f94cf810b122cbfcc184f14cbbe" name="a5aec9f94cf810b122cbfcc184f14cbbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aec9f94cf810b122cbfcc184f14cbbe">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gossip::server::GossipNode::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stop this gossip node. </p><dl class="section return"><dt>Returns</dt><dd>If stop succeed </dd></dl>

</div>
</div>
<a id="ac505abf639dee73e8e05cc4997b57355" name="ac505abf639dee73e8e05cc4997b57355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac505abf639dee73e8e05cc4997b57355">&#9670;&nbsp;</a></span>Token()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gossip::server::GossipNode::Token </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the token of this gossip node. </p><dl class="section return"><dt>Returns</dt><dd>The token of this gossip node </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/tangrenchu/CLionProjects/Gossip/server/<a class="el" href="_gossip_node_8h_source.html">GossipNode.h</a></li>
<li>/Users/tangrenchu/CLionProjects/Gossip/server/GossipNode.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
